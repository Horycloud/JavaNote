## 常见位运算

> 与&，或||，异或^：同0异1

> 任何数 和 0 ^ 都是它本身
>
> 任何数 & 其本身还是本身

> 问容量$2^n$间接考察函数

> 在Java代码中，Int是十进制，或、与运算是针对二进制的，但是我们可以直接写出两个十进制的或/与/异或运算，计算机内部会再把两个十进制转换成二进制，然后进行或/与/异或运算。



### 判偶

> 判断一个十进制数是否为偶数，与运算

+ 先转化为二进制，如果一个数是偶数，那么最右边一位肯定是0。
+ 这样问题就转变为判断二进制最后一位是不是0。
+ 解决方法就是，用最后一位和1进行与运算，结果为0，则为偶数。

```java
public static Boolean isOdd(int n){
		if((ns&1) == 1) return false;
		return true;
}
```



### 1 的个数

> 如何判断一个十进制数的二进制数有多少个1，用与运算+右移

此问题建立在上题基础上。

首先设置一个计数器counter，

从右边开始，每一位和1做与运算，如果结果为1，则计数器+1，

然后每比较一位，进行一次右移，直至遍历到最左边的位置，返回计数器数值即可。

```java
public static int howManyOne(int n){
		if(n == 0) return 0;
		int counter = 0;
		while(n > 0){
        if((n&1) == 1) {
          counter++;
        }
        n = (n >> 1);
		}
		return counter;
}
```



### 去右 1

> 如何==消去==一个二进制数n从右往左第一个1？

解法：让`n&(n-1)`，`result = n&(n-1)`

```java
public static int eliminateRightOne(int n){
		if(n == 0) return 0;
		return n & (n-1);
}
```



> 类似的问题有：如何判断一个数m是否为2的n次幂？

如果m为 $2^n$，则m二进制形式必为 001 000 形式（只有一个1，其余位置全为0），减一为 000 111 ，则m&(m-1)必为0。

且如果一个数不为 $2^n$ ，则其二进制形式则肯定不是001 000，即肯定不止一个位置为1，那么这种情况跟题目「如何==消去==一个二进制数n从右往左第一个1」是相同 的，m&(m-1)只会消去右边第一个1，左边的位置则保持不变，故 m&(m-1) 必不为0。

也就是说，“m为2的n次方“ 和 ”m&(m-1) = 0“ 互为充要条件的

```java
public static Boolean isPower(int m){
		if(m == 0) return false;
		if((m & (m-1)) ==  0) return true;
		return false;
}
```



### 留右 1

> 如何==只保留==从右往左的第一个1，其他位全归 0 ？

解法：`n^{n&(n-1)}`

```java
public static int reserveRightOne(int n){
		if(n == 0) return 0;
		return n ^ ( n&(n-1) );
}
```



## 数字出现次数问题

> 该类问题的通用解法可用HashMap实现，key-数字，value-次数，只是该解法的空间复杂度和时间复杂度均为O(n)，想要降低复杂度，就要选择更加合适的算法。



### 问题一

> 假设一个数组中只有==一个==数字出现了==奇数次==，==其他==的数字都出现了==偶数次==，找出这个出现一次的数字？

方法一：用HashMap统计次数。

方法二：让数组中的数字两两异或，最后的结果即为此数字。（异或满足交换律，任何数异或其本身等于0，任何数和0异或都等与其本身）。



### 问题二

> 假设一个数组中有==两个==数字出现了==奇数次==，==其他==的数字都出现了==偶数次==，找出这两个数字？

此问题基于上面**问题1**，如果把这个数组分成两个数组，而每个数组中各包含这两个数字中的一个，且每个数组中其他元素都出现了偶数次，那么这个问题的子问题就跟前面题一样

那么怎么才能分成满足上述条件的两个数组呢？

解法如下：

① 还是将原数组中的所有元素两两异或，由于这两个数字不相等，那么最终的结果肯定不为0，也就是说结果中的二进制表示中肯定有一个1，那么我们就以从右往左数的第一个1所在的位记为N，然后以“第N位是否为1”为标准，将原数组中的数字分为两组，*第一个子数组中每个数字的第*N*位都为*1*，而第二个子数组的每个数字的第*N*位都为*0。

② 这样划分可以起到一箭双雕的作用，既把两个出现奇数次的数字分在了不同的数组，又保证每个数组中的其他数组均出现了偶数次。

③ 那么如何找出N？这个问题和上面问题”如何只保留从右往左的第一个1，其他位全归0“是一个问题。n=所有元素两两异或结果，N = n^(n&(n-1))。

④ 如何判断N位上是0还是1呢？只需让此数跟N做与运算，结果为0，此位为0；结果为N，此数为1。

⑤ 另外，把原来的数组分为两个数组，这只是一种抽象层的思路，我们不必真的为这两个数组开辟内存空间，可以定义两个变量int temp1、int temp2，让temp0、temp1分别代表这两个数组。

代码：

```java
public static int[] f(int[] nums){
  int[] result = new int[2];
  int temp0 = 0;
  int temp1 = 0;
  int n = 0;
  
  for(int i=0;i<nums.length;i++){
    n ^= nums[i];
  }
  
  int N = n^(n&(n-1));
  for(int i=0;i<nums.length;i++){
    if(0 ==(N & nums[i])){
      temp0 ^= nums[i];
    }else if(N == (N & nums[i])){
      temp1 ^= nums[i];
     }
  }
  result[0] = temp0;
  result[1] = temp1;
  return result;
}
```



### 问题三

> 《剑指Offer》P39-"数组中重复的数字"

解法 ①：书上的解法

解法 ②：可转化为问题二，转化后，解法同问题二



### 问题四

> 假设一个数组中有==一个==数字出现了==1次==，==其他==的数字都出现了==3次==，找出这个数字？



### 问题五

> 假设一个数组中有==一个==数字出现了==1次==，==其他==的数字都出现了==k次==，找出这个数字？

此问题为问题四的升级版！





### 问题六

> 有序数组中的单一元素？

**leetcode  $T_{540}$**

**问题描述**：给定一个只包含整数的**有序数组**，每个元素都会出现**两次**，**唯有一个数**出现**一次**，找出这个数。**注意：** 要求**O(log n)**的时间复杂度和**O(1)** 的空间复杂度。看到**O(log n)** 应该想到二分查找法。

解法 ①

分成两段后，含有该单一元素的一段，其长度为奇数；另一端为偶数。

其中涉及到的一些细节比较复杂：

|  mid-1=mid  | mid-1=mid  |  mid+1=mid  |                          mid+1=mid                           |
| :---------: | :--------: | :---------: | :----------------------------------------------------------: |
|    在左     |    在右    |    在左     |                             在右                             |
| right=mid-2 | left=mid+1 | right=mid-1 | left=mid+2若(mid-1 != mid) & (mid+1 != mid)，则mid就是要找的“单一数”。 |

你会发现即使数组没有经过排序，只要将同一元素放在一起，该算法仍然起作用。

例如：`[10, 10, 4, 4, 7, 11, 11, 12, 12, 2, 2]`

他们的顺序无关紧要，重要的是含有单个元素的子数组元素个数为奇数。

解法 ②







