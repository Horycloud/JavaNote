[原文](https://www.jianshu.com/p/48a6bdfccff1)

# 递归

[关于斐波那契数列三种解法及时间复杂度分析](https://mp.weixin.qq.com/s/G-sua_7h15JwZo982XbEBQ)

[一文学会递归解题](https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect)

## 递归简介

> 定义：直接或者间接不断反复调用自身来达到解决问题的方法。这就要求原始问题可以分解成相同问题的子问题（即可调用相同的函数）。

**示例**：阶乘、斐波纳契数列、汉诺塔问题。

## 递归理解

> 关于递归，首先我们

1. 要思考如何定义这个函数（包括参数、返回类型），因为这个函数是要重复利用的，这也就意味着参数和返回类型也是重复的；

2. 其次是要明白函数的含义，也就是说，这个函数的作用是什么，参数是什么，返回的是什么。明白之后，你就记住：给我这么一个函数，传参数进去，我就能干这么一件事。不要陷入自我循环的怪圈，因为人的大脑顶多能装下两三层的递归，而且这样做也是没有意义的；
3. 最后就是要写递归出口，也就是边界条件，什么时候递归停止，通常来说是方法的参数或者方法体中的某个变量，它随着递归的进行，数值或范围逐渐减小，当最后一层的递归终止时，其达到最小。

> 递归三部曲

1. 先递归体，后递归出口（边界）
2. 每次调用必须缩小问题规模
3. 每次问题规模缩小程度必须为`1`。这里的`1`并不是狭义的，比方说如果二分查找的时候，每次缩小一半的规模也是可以的。





## 递归前后语句执行顺序


> 位于递归前后的代码的执行顺序是不同的

**当代码位于递归语句前**

```java
public static void f(int n){
    System.out.println(n-1);
    if(n>1)  f(n-1);
}
```

 f(3) 的执行结果为 :

```
2
1
0
```

可见，位于递归语句前的代码是按**由外到内**的顺序执行的

注意：这里说的是**递归语句前的代码**是按**由外到内**的顺序执行的，而不是整个函数的执行顺序，对于整个函数的执行顺序肯定都是从内到外的，因为它是递归嘛

分析：

+ 当执行 f(3) 时，在 f(3) 内部的执行顺序为先执行 print(2) 再执行 f(2)
+ 同理，在在 f(2) 内部的执行顺序为先执行 print(1) 再执行 f(1)
+  f(1) 只执行 print(0)
+ 最终，执行的顺序为 print(2) -> print(1) -> print(0)



**当代码位于递归语句后**

```java
public static void f(int n){
    if(n>1)  f(n-1);
  	System.out.println(n-1);
}
```

 f(3) 的执行结果为 :

```
0
1
2
```

可见，位于递归语句前的代码是按**由内到外**的顺序执行的

分析：

+ 当执行 f(3) 时，在 f(3) 内部的执行顺序为先执行 f(2) 再执行 print(2)
+ 而 f(2) 内部的执行顺序又是先执行 f(1) 再执行 print(1)
+ f(1) 只执行 print(0)
+ 最终，执行的顺序为 print(0) -> print(1) -> print(2)



**当代码位于递归语句前后**

```java
public static void f(int n){
  	System.out.println(n-1);
    if(n>1)  f(n-1);
  	System.out.println(n+1);
}
```

 f(3) 的执行结果为 :

```java
2
1
0
2
3
4
```

可见，位于递归语句前的代码是按先**由外到内**，再**由内到外**的顺序执行的

分析：

+ 这次直接用公式进行说明，-> 表示执行顺序
+ f(3) = print(2) -> f(2) -> print(4)
+ f(2) = print(1) -> f(1) -> print(3)
+ f(1) = print(0) -> f(2)
+ 最终 f(3) = print(2) -> print(1) -> print(0) -> f(2) -> print(3) -> print(4)





# 分治

定义：待解决复杂的问题能够简化为几个若干个小规模相同的问题，然后逐步划分，使得问题规模减小到可以求解为止。

将原问题分解为n个规模较小的子问题，各子问题间`独立存在`，并且与原问题形式相同。

递归地解决各个子问题。

将各个子问题的解合并得到原问题的解。

示例：棋盘覆盖、找出伪币、求最值、归并排序、快速排序、快速傅里叶变换算法、Karatsuba大数乘法算法。



# 动态规划

[动态规划算法入门，这就够了](https://baijiahao.baidu.com/s?id=1631319141857419948&wfr=spider&for=pc)

定义：动态规划与分治法相似，都是组合子问题的解来解决原问题的解，`与分治法的不同在于：分治法的子问题是相互独立存在的，而动态规划应用于子问题重叠的情况`。

动态规划方法通常用来求解最优化问题，这类问题可以有很多可行解，每个解都有一个值，找到具有最优值的解称为问题的`一个最优解，而不是最优解，可能有多个解都达到最优值`。

设计动态规划算法的步骤:

​		① 刻画一个最优解的结构特征。

​		② 递归地定义最优解的值。

​		③ 计算最优解的值，通常采用自底向上的方法。

​		④ 利用算出的信息构造一个最优解。

示例：0-1背包问题、钢条切割问题等。



# 贪心算法

定义：贪心算法是就问题而言，选择当下最好的选择，**而不从整体最优考虑，通过局部最优希望导致全局最优**。

贪心算法的要素：

贪心选择性质：可以通过局部最优选择来构造全局最优解。换言之，直接做出在当前问题中看来最优的选择，而不必考虑`子问题的解`。

最优子结构：一个问题的最优解包含其子问题的最优解。

贪心算法的设计步骤：

​		① 将最优化问题转换为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解

​		② 证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。

​		③ 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。

示例：背包问题，均分纸牌，最大整数。



# 回溯法

定义：回溯法是一种`搜索算法`，从根节点出发，按照深度优先搜索的策略进行搜索，到达某一节点后 ，探索该节点是否包含该问题的解，如果包含则进入下一个节点进行搜索，若是不包含则回溯到父节点选择其他支路进行搜索。

回溯法的设计步骤：

​		① 针对所给的原问题，定义问题的解空间。

​		② 确定易于搜索的解空间结构。

​		③ 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数除去无效搜索。

示例：0-背包问题、旅行商问题、八皇后问题。

# 分支限界法

定义：`和回溯法相似，也是一种搜索算法`，但回溯法是找出问题的`许多解`，而分支限界法是找出原问题的`一个解`，或是在满足约束条件的解中找出使`某一目标函数值达到极大或极小的解`，即在某种意义下的最优解。

在当前节点（扩展节点）处，先生成其所有的儿子节点（分支），然后再从当前的活节点（当前节点的子节点）表中选择下一个扩展节点。为了有效地选择下一个扩展节点，加速搜索的进程，在每一个活节点处，计算一个函数值（限界），并根据函数值，从当前活节点表中选择一个最有利的节点作为扩展节点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。

分类：

+ FIFO分支限界法

+ 优先队列分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

示例：装载问题，旅行售货员问题。