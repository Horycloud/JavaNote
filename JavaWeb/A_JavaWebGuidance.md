## JavaWeb学习路线

[雷丰阳 JavaWeb](https://www.bilibili.com/video/BV1r4411S7Eh?p=23)     [雷丰阳 SSM框架](https://www.bilibili.com/video/BV1uE411C7CW?p=4)

> Java基础需要深入理解的知识点

+ 流程控制
+ 面对对象的概念
+ Java语法（this指针、重写和重载、final、static等等这些基础的东西）
+ 集合(包括泛型)（常用的集合类）
+ IO流（IO流代码的编写）
+ 反射

> JavaWeb

+ Tomcat(简单过一下)
+ XML/注解(简单过一下)
+ Servlet(**重点理解**)
+ HTTP协议(**重点理解**)
+ Filter过滤器(**重点理解**)
+ Listener监听器(简单过一下)
+ JSP(简单过一下)
+ AJAX、JSON(简单过一下)

> MySQL

+ 索引、锁(**重要**)

> 项目搭建

+ 页面框架使用BootStrap/Materialize框架来搭好
+ 请求处理交由Servlet，返回的数据可以通过AJAX或者使用JSP，DAO层可以使用DbUtils
+ 数据保存在MySQL中

> 最后我们的项目是这样的：

+ 以**Maven**来管理我们的项目
+ 前端通过**BootStrap**来搭建页面框架
+ **SpringBoot**来搭建Java后端环境，**SpringMVC** 处理前端请求(**SpringBoot整合了**)
+ DAO层使用**DbUtils**组件来完成，**MySQL**作为数据库



## JavaWeb 和 Java EE的区别？

Java Web是以Java语言为基础，使用 JSP 和 Servlet 来开发Web程序（通常指网站）

Java EE 是Java的企业级应用，里面包含的功能比较多。Java EE是个大杂烩，包括Applet、EJB、JDBC、JNDI、Servlet、JSP等技术的标准，运行在一个完整的应用服务器上，用来开发大规模、分布式、健壮的网络应用

可以粗略的认为 Java Web 就是  Java EE 的一部分，是成为 Java EE 大师过程中的第一站

> 使用JavaWeb开发的应用

国内：淘宝、京东、工行的网银、12306等

国外：

+ Hadoop、Twitter、Minecraft(我的世界)

+ Amazon、Google、 eBay和的大型电子商务品牌都在使用Java来后台处理
+ Facebook、 Amazon、 IBM、Joost和 Yahoo都在采用Hadoop进行数据处理和分析





## RESTful 架构

[菜鸟教程](https://www.runoob.com/w3cnote/restful-architecture.html)

### **简介**

REST全称是`Representational State Transfer`，中文意思是`表述（编者注：通常译为表征）性状态转移`。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到："我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。" `如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。`

REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。



### **理解 RESTful**

> 含义

要理解RESTful架构，需要理解`Representational State Transfer`这个词组到底是什么意思，它的每一个词都有些什么涵义。

下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。

- 资源与URI
- 统一资源接口
- 资源的表述
- 资源的链接
- 状态的转移

> RESTful 面向资源

REST 是对资源的表述性状态转移，简单地说，RESTful是一种架构的规范与约束、原则，符合这种规范的架构就是RESTful架构。

REST 原则认为URI应该只代表资源的实体，不代表它的形式。

+ `"资源"`是一种信息实体，它可以有多种外在表现形式。我们把"资源"具体呈现出来的形式，叫做它的`"表现层"（Representation）`。
+ 比如，文本可以用 txt 格式表现，也可以用HTML格式、XML格式、JSON格式表现。

资源的地址 在web中就是URL （统一资源标识符），资源是REST系统的核心概念，所有的设计都是以资源为中心。

结合项目怎么识别资源：

+ 商品加入购物车 `购物车`
+ 提交订单 `订单`
+ 创建用户 `用户`

围绕资源进行增删改查，以及对符合特定条件的资源进行列表操作 。针对资源设计接口。

> 资源与URI

REST全称是`表述性状态转移`，那究竟指的是什么的表述? 

其实指的就是`资源`。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：

- 某用户的手机号码
- 某用户的个人信息
- 最多用户订购的GPRS套餐
- 两个产品之间的依赖关系
- 某用户可以办理的优惠套餐
- 某手机号码的潜在价值

要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是`URI(Uniform Resource Identifier)`。

URI 既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循`可寻址性`原则，具有`自描述性`，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的 URI：

- https://github.com/git
- https://github.com/git/git
- https://github.com/git/git/blob/master/block-sha1/sha1.h
- https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08
- https://github.com/git/git/pulls
- https://github.com/git/git/pulls?state=closed

使用`_`或`-`来让URI可读性更好

使用`/`来表示资源的层级关系

使用`?`用来过滤资源

`,`或`;`可以用来表示同级资源的关系

> 统一资源接口

RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。

如果按照HTTP方法的语义来暴露资源，那么接口将会拥有`安全性`和`幂等性`的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。

**POST和PUT用于创建资源时有什么区别?**

POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由`客户端`决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。

我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。

> 资源的表述

上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。

资源的表述包括`数据`和`描述数据的元数据`，例如，HTTP头"Content-Type" 就是这样一个元数据属性。

那么客户端如何知道服务端提供哪种表述形式呢?

答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。

> 资源的链接

我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。

这种反模式忽略了一个核心概念："超媒体即应用状态引擎（hypermedia as the engine of application state）"。 超媒体是什么?

当你浏览Web网页时，从一个链接跳到一个页面，再从另一个链接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来。

要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性称为`连通性`。下面我们具体来看一些例子。

下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。

> 状态的转移

有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。

不过，我们先来讨论一下REST原则中的`无状态通信原则`。乍看之下，好像自相矛盾了，既然无状态，何来状态转移一说?

其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指`服务端不应该保存客户端状态`。

1. **应用状态与资源状态**

实际上，状态应该区分`应用状态`和`资源状态`，`客户端负责维护应用状态，而服务端维护资源状态`。

客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息

+ 服务端将内部资源发布REST服务，客户端通过URL来访问这些资源，这不就是`SOA`所提倡的`“面向服务”`的思想吗？所以，REST也被人们看做是一种“轻量级”的SOA实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。

服务端不需要在请求间保留应用状态，只有在接收到实际请求的时候，服务端才会关注应用状态。

这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。

在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。

但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。

当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。

2. **应用状态的转移**

状态转移到这里已经很好理解了， "会话"状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。

这些类似"下一页"之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。



###  RESRful vs MVC

> **MVC 模式的不足**

1. 每次请求必须经过“控制器->模型->视图”这个流程，用户才能看到最终的展现的界面，这个过程似乎有些复杂。
2. 实际上视图是依赖于模型的，换句话说，如果没有模型，视图也无法呈现出最终的效果。
3. 渲染视图的过程是在服务端来完成的，最终呈现给浏览器的是带有模型的视图页面，性能无法得到很好的优化。

为了使数据展现过程更加直接，并且提供更好的用户体验，我们有必要对MVC模式进行改进。不妨这样来尝试，首先从浏览器发送AJAX请求，然后服务端接受该请求并返回JSON数据返回给浏览器，最后在浏览器中进行界面渲染。

也就是说，我们输入的是AJAX请求，输出的是JSON数据，市面上有这样的技术来实现这个功能吗？答案是REST。

> **REST和当前最普遍应用的MVC是什么关系，互补还是取代？**

两者实际上是不冲突的：

+ RESTful架构的重点在于对URI和http请求的规范化，以及要求服务器端与HTTP请求中的操作类型有相对应的返回资源；
+ MVC是一种软件架构，主要实现逻辑和视图的分离而MVC架构的重点在于`数据层`、`表现层`、`操作层`之间的沟通设计。

传统的Spring MVC Controller 和 RESTful Web Service Controller 之间的关键区别是`Http响应体的创建方式`。传统的 MVC Controller 依赖于视图技术，基于 REST 的 Web Service Controller仅返回`对象`，而对象数据直接以 JSON/XML 的形式写入 HTTP 响应。

**REST会取代MVC吗？还是彼此是互补关系（就像AOP对于OOP）？**

答案是`It depends！`如果我们可以把所有的用户需求都可以抽象为资源，那么MVC就可以退出历史舞台了。如果情况相反，那么我们就需要混合使用REST和MVC。

当然，这是非常理想的论断。可能我们无法找到一种方法可以把所有的用户需求都抽象为资源，因为保证这种抽象的完整性（即真的是所有需求都可以）需要形式化的证明。而且即使被证明出来了，由于开发人员的能力和喜好不同，MVC肯定也会成为不少人的首选。但是对于希望拥抱REST的人来说，这些都没有关系。只要你开发的系统所设计的问题域可以被合理地抽象为资源，那么REST就会成为你的开发利器。

### **总结**

现在广东XXX版本、XXX等项目中均使用传统的RPC、SOAP方式的Web服务，而移动南方基地XXXX项目的后台， 虽然采用了JSON格式进行交互，但还是属于RPC风格的。本文从资源的定义、获取、表述、关联、状态变迁等角度， 试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同，希望本文能对各位理解REST有所帮助。



## 前后端分离

> **什么是前后端分离**？

前后端分离的"前"特指浏览器端(或客户端)。

注意：JSP 属于后端，全称是 Java Server Page，是运行在服务器端JVM之上Servlet容器里的，只是执行的结果是HTML，响应给浏览器。

Java EE先有的Servlet，那时候已经有了ASP(同样要知道是Active **Server** Page的意思)。

由于要在Servlet里面拼大量的HTML代码，所以Java规范学习了ASP，提出JSP。

+ Servlet是Java代码里混入HTML
+ JSP是HTML代码里混入Java。

浏览器根本不关心服务器端是JSP、ASP、PHP，或者还是原始的Servlet，或是静态服务器上的HTML，只要返回的是合法的HTML就可以。

`所以，把JSP中静态的HTML部分拿出来，变成简单的HTML文件，放在HTTP服务器上，浏览器只要获取到这些HTML就可以了。动态的数据部分用HTML里的JS通过AJAX的方式从服务器端获取，然后动态操作Dom，完成动态内容的展示。这样前后端就分离了。`

> **静态资源和数据接口被部署在两个不同的服务上就算前后端分离**？

静态资源和服务(实现接口的业务逻辑)，在开发阶段就分别开发，而部署阶段分别部署在不同服务器上，算是严格意义上的前后端分离。

有些小型项目，开发阶段没有分离开发，也就是说前后端代码在一个Project里。在部署阶段也没有分离，例如静态资源还是放在Tomcat里。这些情况，到底算不算前后端分离，关键是是否"严格"看待。









